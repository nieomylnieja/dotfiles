# run ssh-agent on every tmux or terminal login
# if this won't be enaugh for managing multiple 
# this is only needed for xmonad right now..
# if [ ! -S ~/.ssh/ssh_auth_sock ]; then
#   eval `ssh-agent`
#   ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock
# fi
# export SSH_AUTH_SOCK=~/.ssh/ssh_auth_sock
# ssh-add -l > /dev/null || ssh-add

# allow aliases
shopt -s expand_aliases

# more powerful pattern matching
shopt -s extglob

# expand env variables
shopt -s direxpand

# Set VIM prompt
alias vim='nvim'
set -o vi
export EDITOR="nvim"

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# autojump
source /etc/profile.d/autojump.sh

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# those fancy rust speeders
alias ls='exa --group-directories-first'
alias du='dust'
alias cat='bat'
alias cd='z'

# Alias definitions.
alias cd..='cd ..'
alias l='ls -1 --icons | fzf --preview "if [ -f {2} ]; then bat --style numbers,changes --color=always {2} | head -500; else tree -C {2} | head -500; fi" | sed -r "s/^.{2}//"'
alias la='ls -a'
alias lt='ls --tree --icons'
alias ll='ls -lah'
alias lls='ls -lah | sort -h -k5'
alias cp="rsync --archive --human-readable --progress --verbose --whole-file"
alias v='vim'
alias open='xdg-open'
alias py='python3'
alias c="xclip -sel clip"
# This one helps with the quasi-jsons produced by mongodb...
alias rm_oid="sed -E 's/(.*)(ObjectId\()(.*)(\)(.*))/\1\3\5/'"

# K8s aliases
alias kpod='kubectl get pod | fzf | head -n1 | awk "{print \$1;}" | tr -d "\n" | c'
alias kexec='kubectl exec -it'
alias kn='kubectl get namespace | fzf | awk '"'"'{print $1}'"'"' | xargs kubectl config set-context --current --namespace'
alias kctx='cat ~/.kube/config | yq '"'"'.contexts | .[].name'"'"' | tr -d "\"" | fzf | xargs kubectl config use-context'
alias ktag='kubectl get deployments | fzf | awk '"'"'{print $1}'"'"' | xargs kubectl describe deployment | grep Image | grep -oE "[^:]+$" | tr -d "\n" | xclip -sel c'
alias podEnv='kubectl get pod -o name | ag intake | xargs -I {} kubectl exec {} -- env | ag -v _SERVICE | ag INTAKE'

# vpn for studies
alias ppVPN='snx -s hellfire.put.poznan.pl -u mateusz.hawrus@student.put.poznan.pl'

# docker aliases
alias docker_clean_images='docker rmi $(docker images -a --filter=dangling=true -q)'
alias docker_clean_ps='docker rm $(docker ps --filter=status=exited --filter=status=created -q)'
alias dstop='sudo systemctl stop docker.socket && sudo systemctl stop docker.service'
alias dstart='sudo systemctl start docker.socket && sudo systemctl start docker.service'

alias start_tmux='tmux kill-server || tmux new-session -c $HOME'

# confirm before overwriting something
alias cp="cp -i"
alias mv='mv -i'
alias rm='rm -I'

# git config setup
git config --global commit.template "$DOTFILES/config/git/commit-template"
git config --global core.excludesfile "$DOTFILES/config/git/gitignore-global"
git config --global core.editor "$EDITOR"

# golang coverage
cover () {
    local t=$(mktemp -t cover)
    go test $COVERFLAGS -coverprofile=$t $@ \
        && go tool cover -func=$t \
        && unlink $t
}

## Completion
source /usr/share/bash-completion/bash_completion

# haskell
eval "$(stack --bash-completion-script stack)"

# kubectl autocomplete
source <(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.
alias k=kubectl
# extend completion to work with the alias
complete -F __start_kubectl k

# create file with ancestor dir structure
mkfileP() { 
	mkdir -p "$(dirname "$1")" || return; touch "$1";
}

# Golang GOPATH --> some programs still need it this way.
export GOPATH="$(go env GOPATH)"

# krew path
export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"

# Bash shared search history
[ -f $XDG_CONFIG_HOME/fzf/fzf.bash ] && source $XDG_CONFIG_HOME/fzf/fzf.bash
# Avoid duplicates
HISTCONTROL=ignoredups:erasedups  
# When the shell exits, append to the history file instead of overwriting it
shopt -s histappend
# After each command, append to the history file and reread it
PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a; history -c; history -r"

# java home
export JAVA_HOME="/usr/lib/jvm/java-11-openjdk-amd64"

# Graphviz dot
export GRAPHVIZ_DOT=/usr/bin/dot

# fzf config
export FZF_DEFAULT_COMMAND='fd --type f'
export FZF_DEFAULT_OPTS=$FZF_DEFAULT_OPTS'
--color fg:#88C0D0,hl:#EBCB8B,fg+:#88C0D0,hl+:#EBCB8B,bg+:#434C5E
--color pointer:#BF616A,info:#4C566A,spinner:#4C566A,header:#4C566A,prompt:#B48EAD,marker:#EBCB8B'

export FZF_ALT_C_COMMAND='fd --type d'
export FZF_ALT_C_OPTS='--preview "tree -C {} | head -500"'

export FZF_CTRL_T_COMMAND='fd --type f'
export FZF_CTRL_T_OPTS='--preview "bat --style numbers,changes --color=always {} | head -500"'

export FZF_COMPLETION_OPTS='--border --info=inline'
export FZF_COMPLETION_TRIGGER='**'

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type d --hidden --follow --exclude ".git" . "$1"
}

# (EXPERIMENTAL) Advanced customization of fzf options via _fzf_comprun function
# - The first argument to the function is the name of the command.
# - You should make sure to pass the rest of the arguments to fzf.
_fzf_comprun() {
  local command=$1
  shift

  case "$command" in
    cd)           fzf "$@" --preview 'tree -C {} | head -200' ;;
    export|unset) fzf "$@" --preview "eval 'echo \$'{}" ;;
    ssh)          fzf "$@" --preview 'dig {}' ;;
    *)            fzf "$@" ;;
  esac
}

# pfetch configuration
export PF_INFO="ascii title os host kernel uptime pkgs memory wm shell editor"

# nord dircolors
test -r ~/.dotfiles/nord-dircolors/src/dir_colors && eval $(dircolors ~/.dotfiles/nord-dircolors/src/dir_colors)
if [ ! -f ~/.dir_colors ]; then
  ln "$DOTFILES/nord_dircolors/src/dir_colors" ~/.dir_colors
fi

# bat colors
export BAT_THEME="Nord"

# delta diff tool, since we're building it using cargo...
export PATH="$DOTFILES/delta/target/release:$PATH"

# node version manager
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# python gitlab cli
export PYTHON_GITLAB_CFG="$HOME/.config/python-gitlab-cli/.python-gitlab.cfg"

# colored man pages
export LESS_TERMCAP_mb=$'\e[1;34m'
export LESS_TERMCAP_md=$'\e[1;34m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;95m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;96m'

# bash search history
export HISTSIZE=10000
export HISTFILESIZE=10000

#ignore upper and lowercase when TAB completion
bind "set completion-ignore-case on"

### ARCHIVE EXTRACTION
# usage: ex <file>
ex ()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1   ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *.deb)       ar x $1      ;;
      *.tar.xz)    tar xf $1    ;;
      *.tar.zst)   unzstd $1    ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Spicetify -- an awesome spotify customization cli
export SPICETIFY_INSTALL="$HOME/spicetify-cli"
export PATH="$SPICETIFY_INSTALL:$PATH"

# pyenv path -- place it toward the end of bashrc
export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv virtualenv-init -)"

# any other custom files to be sourced
source "$HOME"/nobl9/nobl9rc.bash

# Zoxide (cd replacement)
eval "$(zoxide init bash)"

# Run dircolors to set LS_COLORS in the envs
eval "$(dircolors)" 

# starship prompt init, should stay on the bottom
eval "$(starship init bash)"

# l1
[ -f "${XDG_CONFIG_HOME:-$HOME/.config}"/fzf/fzf.bash ] && source "${XDG_CONFIG_HOME:-$HOME/.config}"/fzf/fzf.bash

# Generated for envman. Do not edit.
[ -s "$HOME/.config/envman/load.sh" ] && source "$HOME/.config/envman/load.sh"

